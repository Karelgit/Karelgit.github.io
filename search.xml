<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>几种分布式锁的集中实现</title>
    <url>/2020/05/25/%E5%87%A0%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E9%9B%86%E4%B8%AD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1>分布式锁实现</h1>
<p>之前因为接触到这篇分布式锁的文章，地址是：<a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5" target="_blank" rel="noopener">再有人问你分布式锁，这篇文章扔给他</a>，自己兴趣浓烈，决定把里面提到的东西实现一遍，Mysql提到的分布式锁主要还是依赖mysql的事务和锁结构表的维护实现，相对简单，下面只讲Zookeeper和redis分布式锁，包括源码解析。<a id="more"></a></p>
<h2 id="Zookeeper的实现"><a class="header-anchor" href="#Zookeeper的实现">¶</a>Zookeeper的实现</h2>
<p>Zookeeper里面提供的3个分布式锁，分别为InterProcessMutex-可重入互斥锁、InterProcessSemaphoreMutex-不可重入互斥锁、InterProcessReadWriteLock-可重入读写锁，下面对三种锁的源码进行解析，其中第一个InterProcessMutex-可重入互斥锁源码分析参考文章：<a href="https://www.jianshu.com/p/d12bf3f4017c" target="_blank" rel="noopener">Zookeeper源码分析1-分布式锁</a>，感谢作者！其他为个人发布。</p>
<h3 id="InterProcessMutex-可重入互斥锁"><a class="header-anchor" href="#InterProcessMutex-可重入互斥锁">¶</a>InterProcessMutex-可重入互斥锁</h3>
<h4 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutex</span> <span class="keyword">implements</span> <span class="title">InterProcessLock</span>, <span class="title">Revocable</span>&lt;<span class="title">InterProcessMutex</span>&gt;</span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LockInternals         internals;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String                basePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理可重入的存储线程和锁数据的ConcurrentMap</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt;   threadData = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockData</span></span></span><br><span class="line"><span class="class">  </span>{</span><br><span class="line">      <span class="keyword">final</span> Thread        owningThread;</span><br><span class="line">      <span class="keyword">final</span> String        lockPath;</span><br><span class="line">      <span class="keyword">final</span> AtomicInteger lockCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">LockData</span><span class="params">(Thread owningThread, String lockPath)</span></span></span><br><span class="line"><span class="function">      </span>{</span><br><span class="line">          <span class="keyword">this</span>.owningThread = owningThread;</span><br><span class="line">          <span class="keyword">this</span>.lockPath = lockPath;</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_NAME = <span class="string">"lock-"</span>;		</span><br><span class="line"><span class="comment">// 最常用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String path)</span></span>{</span><br><span class="line">      <span class="comment">// Zookeeper 利用 path 创建临时顺序节点，实现公平锁的核心</span></span><br><span class="line">      <span class="keyword">this</span>(client, path, <span class="keyword">new</span> StandardLockInternalsDriver());</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String path, LockInternalsDriver driver)</span></span>{</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      *	maxLeases=1，表示可以获得分布式锁的线程数量（跨 JVM）为 1，即为互斥锁。</span></span><br><span class="line"><span class="comment">      *	租约，表示同一时间内可以连接到服务端的客户端个数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">this</span>(client, path, LOCK_NAME, <span class="number">1</span>, driver);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// protected 构造函数</span></span><br><span class="line">  InterProcessMutex(CuratorFramework client, String</span><br><span class="line">          path, String lockName, <span class="keyword">int</span> maxLeases,</span><br><span class="line">                    LockInternalsDriver driver){</span><br><span class="line">      basePath = PathUtils.validatePath(path);</span><br><span class="line">      <span class="comment">/* internals 的类型为 LockInternals ，</span></span><br><span class="line"><span class="comment">      *	InterProcessMutex 将分布式锁的申请和释放操作委托给internals 执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      internals = <span class="keyword">new</span> LockInternals(client, driver, path,</span><br><span class="line">              lockName, maxLeases);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="acquire，获取锁"><a class="header-anchor" href="#acquire，获取锁">¶</a>acquire，获取锁</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 无限等待</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">      <span class="keyword">if</span> (!internalLock(-<span class="number">1</span>, <span class="keyword">null</span>)) {</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Lost connection while trying to acquire lock:"</span> + basePath);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 限时等待</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">      <span class="keyword">return</span> internalLock(time, unit);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="internalLock"><a class="header-anchor" href="#internalLock">¶</a>internalLock</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"> 				 <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Note on concurrency: a given lockData instance</span></span><br><span class="line"><span class="comment">           can be only acted on by a single thread so locking isn't necessary</span></span><br><span class="line"><span class="comment">           并发注意：一个给定LockData实例只能被单一线程操作，所以锁定不是必须的。这里和release形成呼应，就是同一个线程，如果里面的LockData的lockCount减少到0之后，release才删除在threadData的线程信息，否则仍然保持拥有锁（具体见release里面的逻辑）。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Thread currentThread =</span><br><span class="line">                Thread.currentThread();</span><br><span class="line">        LockData lockData =</span><br><span class="line">                threadData.get(currentThread);</span><br><span class="line">        <span class="keyword">if</span> (lockData != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *	实现可重入</span></span><br><span class="line"><span class="comment">            *	同一线程再次 acquire，首先判断当前的映射表内（threadData）是否有该线程的锁信息，如果有则</span></span><br><span class="line"><span class="comment">            *	原子 + 1，然后返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            lockData.lockCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 映射表内没有对应的锁信息，尝试通过LockInternals 获取锁</span></span><br><span class="line">        String lockPath = internals.attemptLock(time,unit, getLockNodeBytes());</span><br><span class="line">        <span class="keyword">if</span> (lockPath != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 成功获取锁，记录信息到映射表</span></span><br><span class="line">            LockData newLockData = <span class="keyword">new</span></span><br><span class="line">                    LockData(currentThread, lockPath);</span><br><span class="line">            threadData.put(currentThread,</span><br><span class="line">                    newLockData);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射表</span></span><br><span class="line">    <span class="comment">// 记录线程与锁信息的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt;  threadData = Maps.newConcurrentMap();</span><br><span class="line">    <span class="comment">// 锁信息</span></span><br><span class="line">    <span class="comment">// Zookeeper 中一个临时顺序节点对应一个“锁”，但让锁生效激活需要排队（公平锁），下面会继续分析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LockData</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Thread owningThread;</span><br><span class="line">        <span class="keyword">final</span> String lockPath;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger lockCount = <span class="keyword">new</span></span><br><span class="line">                AtomicInteger(<span class="number">1</span>); <span class="comment">// 分布式锁重入次数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LockData</span><span class="params">(Thread owningThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                         String lockPath)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.owningThread = owningThread;</span><br><span class="line">            <span class="keyword">this</span>.lockPath = lockPath;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="attemptLock"><a class="header-anchor" href="#attemptLock">¶</a>attemptLock</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁，并返回锁对应的 Zookeeper 临时顺序节点的路径</span></span><br><span class="line"> <span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> startMillis = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">// 无限等待时，millisToWait 为 null</span></span><br><span class="line">     <span class="keyword">final</span> Long millisToWait = (unit != <span class="keyword">null</span>) ?</span><br><span class="line">             unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 创建 ZNode 节点时的数据内容，无关紧要，这里为 null，采用默认值（IP 地址）</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">byte</span>[] localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">     <span class="comment">// 当前已经重试次数，与CuratorFramework的重试策略有关</span></span><br><span class="line">     <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 在 Zookeeper 中创建的临时顺序节点的路径，相当于一把待激活的分布式锁</span></span><br><span class="line">     <span class="comment">// 激活条件：同级目录子节点，名称排序最小（排队，公平锁），后续继续分析</span></span><br><span class="line">     String ourPath = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 是否已经持有分布式锁</span></span><br><span class="line">     <span class="keyword">boolean</span> hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 是否已经完成尝试获取分布式锁的操作</span></span><br><span class="line">     <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">while</span> (!isDone) {</span><br><span class="line">         isDone = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">             <span class="comment">// 从 InterProcessMutex 的构造函数可知实际 driver 为 StandardLockInternalsDriver 的实例</span></span><br><span class="line">             <span class="comment">// 在Zookeeper中创建临时顺序节点</span></span><br><span class="line">             ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">             <span class="comment">// 循环等待来激活分布式锁，实现锁的公平性</span></span><br><span class="line">             hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">         } <span class="keyword">catch</span></span><br><span class="line">         (KeeperException.NoNodeException e) {</span><br><span class="line">             <span class="comment">// 容错处理，不影响主逻辑的理解，可跳过</span></span><br><span class="line">             <span class="comment">// 因 为 会 话 过 期 等 原 因 ，StandardLockInternalsDriver 因为无法找到创建的临时 顺序节点而抛出 NoNodeException 异常</span></span><br><span class="line">             <span class="keyword">if</span> (client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++,</span><br><span class="line">                     System.currentTimeMillis() -</span><br><span class="line">                             startMillis, RetryLoop.getDefaultRetrySleeper())) {</span><br><span class="line">                 <span class="comment">// 满足重试策略尝试重新获取锁</span></span><br><span class="line">                 isDone = <span class="keyword">false</span>;</span><br><span class="line">             } <span class="keyword">else</span> {</span><br><span class="line">                 <span class="comment">// 不满足重试策略则继续抛出NoNodeException</span></span><br><span class="line">                 <span class="keyword">throw</span> e;</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span> (hasTheLock) {</span><br><span class="line">         <span class="comment">// 成功获得分布式锁，返回临时顺序节点的路径，上层将其封装成锁信息记录在映射表，方便锁重入</span></span><br><span class="line">         <span class="keyword">return</span> ourPath;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 获取分布式锁失败，返回 null</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="createsTheLock"><a class="header-anchor" href="#createsTheLock">¶</a>createsTheLock</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// From StandardLockInternalsDriver</span></span><br><span class="line">  <span class="comment">// 在 Zookeeper 中创建临时顺序节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework</span></span></span><br><span class="line"><span class="function"><span class="params">                                       client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">          Exception </span>{</span><br><span class="line">      String ourPath;</span><br><span class="line">      <span class="comment">// lockNodeBytes 不为 null 则作为数据节点内容，否则采用默认内容（IP 地址）</span></span><br><span class="line">      <span class="keyword">if</span> (lockNodeBytes != <span class="keyword">null</span>) {</span><br><span class="line">          <span class="comment">// 下面对 CuratorFramework 的一些细节做解释，不影响对分布式锁主逻辑的解释，可跳过</span></span><br><span class="line">          <span class="comment">// creatingParentContainersIfNeeded：用于创建父节点，如果不支持 CreateMode.CONTAINER</span></span><br><span class="line">          <span class="comment">// 那么将采用 CreateMode.PERSISTENT</span></span><br><span class="line">          <span class="comment">// withProtection：临时子节点会添加GUID前缀</span></span><br><span class="line">          ourPath = client.create().creatingParentContainersIfNeeded()</span><br><span class="line">                  <span class="comment">//CreateMode.EPHEMERAL_SEQUENTIAL：临时顺序节点，Zookeeper 能保证在节点产生的顺序性</span></span><br><span class="line">                  <span class="comment">// 依据顺序来激活分布式锁，从而也实现了分布式锁的公平性，后续继续分析</span></span><br><span class="line">                  .withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">          ourPath =</span><br><span class="line">                  client.create().creatingParentContainersIfNeeded()</span><br><span class="line">                          .withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> ourPath;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="internalLockLoop"><a class="header-anchor" href="#internalLockLoop">¶</a>internalLockLoop</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 循环等待来激活分布式锁，实现锁的公平性</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       <span class="comment">// 是否已经持有分布式锁</span></span><br><span class="line">       <span class="keyword">boolean</span> haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 是否需要删除子节点</span></span><br><span class="line">       <span class="keyword">boolean</span> doDelete = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="keyword">if</span> (revocable.get() != <span class="keyword">null</span>) {</span><br><span class="line">               client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">while</span> ((client.getState() ==</span><br><span class="line">                   CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock) {</span><br><span class="line">               <span class="comment">// 获取排序后的子节点列表</span></span><br><span class="line">               List&lt;String&gt; children = getSortedChildren();</span><br><span class="line">               <span class="comment">// 获取前面自己创建的临时顺序子节点的名称</span></span><br><span class="line">               String sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>);</span><br><span class="line">               <span class="comment">// 实现锁的公平性的核心逻辑，看下面的分析</span></span><br><span class="line">               PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">               <span class="keyword">if</span> (predicateResults.getsTheLock()) {</span><br><span class="line">                   <span class="comment">// 获得了锁，中断循环，继续返回上层</span></span><br><span class="line">                   haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">               } <span class="keyword">else</span> {</span><br><span class="line">                   <span class="comment">// 没有获得到锁，监听上一临时顺序节点</span></span><br><span class="line">                   String previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line">                   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                       <span class="keyword">try</span> {</span><br><span class="line">                           <span class="comment">// exists()会导致导致资源泄漏，因此 exists () 可以监听不存在的 ZNode，因此采用 getData ()</span></span><br><span class="line">                           <span class="comment">// 上一临时顺序节点如果被删除，会唤醒当前线程继续竞争锁，正常情况下能直接获得锁，因为锁是公平的</span></span><br><span class="line"></span><br><span class="line">                           client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                           <span class="keyword">if</span> (millisToWait != <span class="keyword">null</span>) {</span><br><span class="line">                               millisToWait -=</span><br><span class="line">                                       (System.currentTimeMillis() - startMillis);</span><br><span class="line">                               startMillis =</span><br><span class="line">                                       System.currentTimeMillis();</span><br><span class="line">                               <span class="keyword">if</span> (millisToWait &lt;=</span><br><span class="line">                                       <span class="number">0</span>) {</span><br><span class="line">                                   doDelete =</span><br><span class="line">                                           <span class="keyword">true</span>; <span class="comment">// 获取锁超时，标记删除之前创建的临时顺序节点</span></span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               }</span><br><span class="line">                               wait(millisToWait);</span><br><span class="line">                               <span class="comment">// 等待被唤醒，限时等待</span></span><br><span class="line">                           } <span class="keyword">else</span> {</span><br><span class="line">                               wait(); <span class="comment">// 等待被唤醒，无限等待</span></span><br><span class="line">                           }</span><br><span class="line">                       } <span class="keyword">catch</span></span><br><span class="line">                       (KeeperException.NoNodeException e) {</span><br><span class="line">                           <span class="comment">// 容错处理，逻辑稍微有点绕，可跳过，不影响主逻辑的理解</span></span><br><span class="line">                           <span class="comment">// client.getData()可能调用时抛出 NoNodeException，原因可能是锁被释放或会话过期（连接丢失）等</span></span><br><span class="line">                           <span class="comment">// 这里并没有做任何处理，因为外层是 while 循环，再次执行 driver.getsTheLock 时会调用 validateOurIndex</span></span><br><span class="line">                           <span class="comment">// 此 时 会 抛 出NoNodeException，从而进入下面的 catch 和 finally 逻辑，重新抛出上层尝试重试获取锁并删除临时顺序节点</span></span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           ThreadUtils.checkInterrupted(e);</span><br><span class="line">           <span class="comment">// 标记删除，在 finally 删除之前创建的临时顺序节点（后台不断尝试）</span></span><br><span class="line">           doDelete = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// 重新抛出，尝试重新获取锁</span></span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">if</span> (doDelete) {</span><br><span class="line">               deleteOurPath(ourPath);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> haveTheLock;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="getsTheLock"><a class="header-anchor" href="#getsTheLock">¶</a>getsTheLock</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// From StandardLockInternalsDriver</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 之前创建的临时顺序节点在排序后的子节点列表中的索引</span></span><br><span class="line">        <span class="keyword">int</span> ourIndex =</span><br><span class="line">                children.indexOf(sequenceNodeName);</span><br><span class="line">        <span class="comment">// 校验之前创建的临时顺序节点是否有效</span></span><br><span class="line">        validateOurIndex(sequenceNodeName,</span><br><span class="line">                ourIndex);</span><br><span class="line">        <span class="comment">// 锁公平性的核心逻辑</span></span><br><span class="line">        <span class="comment">// 由 InterProcessMutex 的构造函数可知， maxLeases 为 1，即只有 ourIndex 为 0 时，线程才能持有锁，或者说该线程创建的临时顺序节点激活了锁</span></span><br><span class="line">        <span class="comment">// Zookeeper 的临时顺序节点特性能保证跨多个 JVM 的线程并发创建节点时的顺序性，越早创建临时顺序节点成功的线程会更早地激活锁或获得锁</span></span><br><span class="line">        <span class="keyword">boolean</span> getsTheLock = ourIndex &lt;</span><br><span class="line">                maxLeases;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁，则无需监听任何节点，否则需要监听上一顺序节点（ourIndex - 1）</span></span><br><span class="line">        <span class="comment">// 因 为 锁 是 公 平 的 ， 因 此 无 需 监 听 除 了（ourIndex - 1）以外的所有节点，这是为了减少羊群效应， 非常巧妙的设计！！</span></span><br><span class="line">        String pathToWatch = getsTheLock ? <span class="keyword">null</span> :</span><br><span class="line">                children.get(ourIndex - maxLeases);</span><br><span class="line">        <span class="comment">// 返回获取锁的结果，交由上层继续处理（添加监听等操作）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch,</span><br><span class="line">                getsTheLock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validateOurIndex</span><span class="params">(String sequenceNodeName, <span class="keyword">int</span> ourIndex)</span> <span class="keyword">throws</span> KeeperException </span>{</span><br><span class="line">        <span class="keyword">if</span> (ourIndex &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 容错处理，可跳过</span></span><br><span class="line">            <span class="comment">// 由于会话过期或连接丢失等原因，该线程创建的临时顺序节点被 Zookeeper 服务端删除，往外抛出 NoNodeException</span></span><br><span class="line">            <span class="comment">// 如果在重试策略允许范围内，则进行重新尝试获取锁，这会重新重新生成临时顺序节点</span></span><br><span class="line">            <span class="comment">// 佩服 Curator 的作者将边界条件考虑得 如此周到！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException(<span class="string">"Sequential path  not found:"</span> + sequenceNodeName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="release"><a class="header-anchor" href="#release">¶</a>release</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line">       LockData lockData = threadData.get(currentThread);</span><br><span class="line">       <span class="keyword">if</span> (lockData == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="comment">// 无法从映射表中获取锁信息，不持有锁</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock:"</span> + basePath);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">       <span class="keyword">if</span> (newLockCount &gt; <span class="number">0</span>) {</span><br><span class="line">           <span class="comment">// 锁是可重入的，初始值为 1，原子-1 到0，锁才释放</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> (newLockCount &lt; <span class="number">0</span>) {</span><br><span class="line">           <span class="comment">// 理论上无法执行该路径</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gonenegative for lock:"</span> + basePath);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">// lockData != null &amp;&amp; newLockCount == 0，释放锁资源</span></span><br><span class="line">           internals.releaseLock(lockData.lockPath);</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="comment">// 最后从映射表中移除当前线程的锁信息</span></span><br><span class="line">           threadData.remove(currentThread);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试过程"><a class="header-anchor" href="#测试过程">¶</a>测试过程</h4>
<p>测试代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework curatorFramework = CuratorFrameworkFactory.builder().</span><br><span class="line">            connectString(CONNECTION_STR).sessionTimeoutMs(<span class="number">5000</span>).</span><br><span class="line">            retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).build();</span><br><span class="line">    curatorFramework.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(curatorFramework, <span class="string">"/locks"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;尝试竞争读"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//阻塞竞争锁</span></span><br><span class="line">                lock.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功获得了锁"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功释放了锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试结果：</p>
<p><img src="/images/loading.gif" data-original="monitor-1.png" alt="Screen Shot 2020-05-14 at 11.46.09 AM"></p>
<h3 id="InterProcessSemaphoreMutex"><a class="header-anchor" href="#InterProcessSemaphoreMutex">¶</a>InterProcessSemaphoreMutex</h3>
<p>不可重入互斥锁，不再通过线程的map ThreadMap进行重入的记录，使用租约Lease来获得与服务器的链接</p>
<h4 id="构造函数-v2"><a class="header-anchor" href="#构造函数-v2">¶</a>构造函数</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreMutex</span> <span class="keyword">implements</span> <span class="title">InterProcessLock</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessSemaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Lease lease;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client the client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path path for the lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterProcessSemaphoreMutex</span><span class="params">(CuratorFramework client, String path)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> InterProcessSemaphore(client, path, <span class="number">1</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="acquire，获得锁"><a class="header-anchor" href="#acquire，获得锁">¶</a>acquire，获得锁</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">		<span class="comment">//无限等待，使用semaphore,只是返回一个租约，后面的acquire和release过程依然委托给InterProcessMutex的LockInternals，在以上的的可重入互斥锁里面有详细分析，不可重入互斥锁没有了使用threadData ConcurrentMap来处理重入过程</span></span><br><span class="line">    lease = semaphore.acquire();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>{	</span><br><span class="line">		<span class="comment">//有限等待</span></span><br><span class="line">    Lease acquiredLease = semaphore.acquire(time, unit);</span><br><span class="line">    <span class="keyword">if</span> ( acquiredLease == <span class="keyword">null</span> )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// important - don't overwrite lease field if couldn't be acquired</span></span><br><span class="line">    }</span><br><span class="line">    lease = acquiredLease;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Lease租约"><a class="header-anchor" href="#Lease租约">¶</a>Lease租约</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lease</span> <span class="keyword">extends</span> <span class="title">Closeable</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases the lease so that other clients/processes can acquire it</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the data stored in the node for this lease</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[]   getData() <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="InterProcessSemaphore"><a class="header-anchor" href="#InterProcessSemaphore">¶</a>InterProcessSemaphore</h4>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphore</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger        log = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LockInternals internals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String     LOCK_NAME = <span class="string">"lock-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client the client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path path for the semaphore</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxLeases the max number of leases to allow for this instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterProcessSemaphore</span><span class="params">(CuratorFramework client, String path, <span class="keyword">int</span> maxLeases)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>(client, path, maxLeases, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>{</span><br><span class="line">      	 	<span class="comment">//无限等待去获取租约</span></span><br><span class="line">          String      path = internals.attemptLock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">return</span> makeLease(path);</span><br><span class="line">      }</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquire a lease. If no leases are available, this method blocks until either the maximum</span></span><br><span class="line"><span class="comment">     * number of leases is increased or another client/process closes a lease. However, this method</span></span><br><span class="line"><span class="comment">     * will only block to a maximum of the time parameters given.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The client must close the lease when it is done with it. You should do this in a</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;finally&lt;/code&gt; block.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	获取租约的时候，如果没有lease可用(其实就是拿不到lock的ZooKeeper的path,lease是通过这个path来形</span></span><br><span class="line"><span class="comment">     *	成租约的)，这个方法将锁定并等待，知道增加到最大租约数，或者其他客户端/进程关掉租约。然而，这个方法锁</span></span><br><span class="line"><span class="comment">     *	定等待的时间只达到time所给的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	方法执行之后客户端必须关闭租约，你用该在finally里面去执行。</span></span><br><span class="line"><span class="comment">     *	</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit time unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new lease or null if time ran out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception ZK errors, interruptions, etc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">      	<span class="comment">//有限等待去获取租约</span></span><br><span class="line">        String      path = internals.attemptLock(time, unit, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> (path != <span class="keyword">null</span>) ? makeLease(path) : <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//生成租约</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> Lease <span class="title">makeLease</span><span class="params">(<span class="keyword">final</span> String path)</span></span></span><br><span class="line"><span class="function">      </span>{</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Lease()</span><br><span class="line">          {</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">              </span>{</span><br><span class="line">                  <span class="keyword">try</span></span><br><span class="line">                  {</span><br><span class="line">                      internals.releaseLock(path);</span><br><span class="line">                  }</span><br><span class="line">                  <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">                  {</span><br><span class="line">                      log.warn(<span class="string">"Lease already released"</span>, e);</span><br><span class="line">                  }</span><br><span class="line">                  <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">                  {</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() <span class="keyword">throws</span> Exception</span><br><span class="line">              {</span><br><span class="line">                  <span class="keyword">return</span> internals.getClient().getData().forPath(path);</span><br><span class="line">              }</span><br><span class="line">          };</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试过程-v2"><a class="header-anchor" href="#测试过程-v2">¶</a>测试过程</h4>
<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        CuratorFramework curatorFramework = CuratorFrameworkFactory.builder().</span><br><span class="line">                connectString(CONNECTION_STR).sessionTimeoutMs(<span class="number">5000</span>).</span><br><span class="line">                retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).build();</span><br><span class="line">        curatorFramework.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> InterProcessSemaphoreMutex lock = <span class="keyword">new</span> InterProcessSemaphoreMutex(curatorFramework,<span class="string">"/locks"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;尝试竞争读"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//阻塞竞争锁</span></span><br><span class="line">                    lock.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功获得了锁"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">//释放锁</span></span><br><span class="line">                        lock.release();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功释放了锁"</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }, <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>测试结果：</p>
<p><img src="/images/loading.gif" data-original="monitor-2.png" alt="Screen Shot 2020-05-14 at 11.34.41 AM"></p>
<h3 id="InterProcessReadWriteLock"><a class="header-anchor" href="#InterProcessReadWriteLock">¶</a>InterProcessReadWriteLock</h3>
<p>下面是InterProcessReadWriteLock的类，我们读锁的调用链条是interProcessReadWriteLock.readLock().acquire()，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *    A re-entrant read/write mutex that works across JVMs. Uses Zookeeper to hold the lock. 	All processes</span></span><br><span class="line"><span class="comment"> *    in all JVMs that use the same lock path will achieve an inter-process critical section. Further, this mutex is</span></span><br><span class="line"><span class="comment"> *    "fair" - each user will get the mutex in the order requested (from ZK's point of view).</span></span><br><span class="line"><span class="comment"> *    可重入互斥锁通过JVM工作，使用Zookeeper来控制，所有进程通过同一个lock节点路径获取进程间关键部分。另外，这个互斥锁是公平的，依赖于请求顺序。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *    A read write lock maintains a pair of associated locks, one for read-only operations and one</span></span><br><span class="line"><span class="comment"> *    for writing. The read lock may be held simultaneously by multiple reader processes, so long as</span></span><br><span class="line"><span class="comment"> *    there are no writers. The write lock is exclusive.</span></span><br><span class="line"><span class="comment"> *    锁包含一对相关的子锁，一个负责只读一个负责写，一旦线程里面没有写锁，读锁被多线程中同步持有。写锁是独占的。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;b&gt;Reentrancy&lt;/b&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *    This lock allows both readers and writers to reacquire read or write locks in the style of a</span></span><br><span class="line"><span class="comment"> *    re-entrant lock. Non-re-entrant readers are not allowed until all write locks held by the</span></span><br><span class="line"><span class="comment"> *    writing thread/process have been released. Additionally, a writer can acquire the read lock, but not</span></span><br><span class="line"><span class="comment"> *    vice-versa. If a reader tries to acquire the write lock it will never succeed.&lt;br/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *    "重入性"</span></span><br><span class="line"><span class="comment"> *    锁包含读锁和写锁进行重入地进行读和写的锁定，不是重入的读操作者不被允许，直到写锁在被线程/进程的操作被释                 	*    被释放。另外，写操作者可以获取读锁，相反则不成立，一个读操作者获取写锁是绝对不会成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    &lt;b&gt;Lock downgrading&lt;/b&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *    Re-entrancy also allows downgrading from the write lock to a read lock, by acquiring the write</span></span><br><span class="line"><span class="comment"> *    lock, then the read lock and then releasing the write lock. However, upgrading from a read</span></span><br><span class="line"><span class="comment"> *    lock to the write lock is not possible.</span></span><br><span class="line"><span class="comment"> *    "锁降级"</span></span><br><span class="line"><span class="comment"> *    重入机制允许写锁降级为读锁，通过获取写锁，变成读锁，然后后释放掉写锁。然而，从读锁升级到写锁是不可以的。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessReadWriteLock</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readMutex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeMutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// must be the same length. LockInternals depends on it</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ_LOCK_NAME  = <span class="string">"__READ__"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_LOCK_NAME = <span class="string">"__WRIT__"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SortingLockInternalsDriver</span> <span class="keyword">extends</span> <span class="title">StandardLockInternalsDriver</span></span></span><br><span class="line"><span class="class">    </span>{</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">      	*</span></span><br><span class="line"><span class="comment">      	*从fixForSorting里面返回的str是顺序节点的顺序值，如_c_8edecf62-2ce9-4413-b77e-2411861ac8db-__WRIT__0000000029,</span></span><br><span class="line"><span class="comment">      	*str是：0000000029，这里面是作为LockInternals里面的上级监控点提供一个数值来确定是哪一个lock的</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">fixForSorting</span><span class="params">(String str, String lockName)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            str = <span class="keyword">super</span>.fixForSorting(str, READ_LOCK_NAME);</span><br><span class="line">            str = <span class="keyword">super</span>.fixForSorting(str, WRITE_LOCK_NAME);</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalInterProcessMutex</span> <span class="keyword">extends</span> <span class="title">InterProcessMutex</span></span></span><br><span class="line"><span class="class">    </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line">        InternalInterProcessMutex(CuratorFramework client, String path, String lockName, <span class="keyword">int</span> maxLeases, LockInternalsDriver driver)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">super</span>(client, path, lockName, maxLeases, driver);</span><br><span class="line">            <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getParticipantNodes</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            Collection&lt;String&gt;  nodes = <span class="keyword">super</span>.getParticipantNodes();</span><br><span class="line">            Iterable&lt;String&gt;    filtered = Iterables.filter</span><br><span class="line">            (</span><br><span class="line">                nodes,</span><br><span class="line">                <span class="keyword">new</span> Predicate&lt;String&gt;()</span><br><span class="line">                {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(String node)</span></span></span><br><span class="line"><span class="function">                    </span>{</span><br><span class="line">                        <span class="keyword">return</span> node.contains(lockName);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> ImmutableList.copyOf(filtered);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client the client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePath path to use for locking</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">      <span class="comment">//写锁初始化</span></span><br><span class="line">        writeMutex = <span class="keyword">new</span> InternalInterProcessMutex</span><br><span class="line">        (</span><br><span class="line">            client,</span><br><span class="line">            basePath,</span><br><span class="line">            WRITE_LOCK_NAME,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="keyword">new</span> SortingLockInternalsDriver()</span><br><span class="line">            {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">                </span>{</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="comment">//读锁初始化</span></span><br><span class="line">        readMutex = <span class="keyword">new</span> InternalInterProcessMutex</span><br><span class="line">        (</span><br><span class="line">            client,</span><br><span class="line">            basePath,</span><br><span class="line">            READ_LOCK_NAME,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            <span class="keyword">new</span> SortingLockInternalsDriver()</span><br><span class="line">            {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">                </span>{</span><br><span class="line">                  <span class="comment">/**</span></span><br><span class="line"><span class="comment">                  *读锁的初始化和写锁不同，写锁继承父类的getsTheLock方法，</span></span><br><span class="line"><span class="comment">                  *而读锁自己实现了获取锁的逻辑readLockPredicate,PredicateResults里面包含成员变量</span></span><br><span class="line"><span class="comment">                  * boolean   getsTheLock(是否获得锁)，String pathToWatch监听的路径</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                    <span class="keyword">return</span> readLockPredicate(children, sequenceNodeName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> read lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InterProcessMutex     <span class="title">readLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> readMutex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> write lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InterProcessMutex     <span class="title">writeLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> writeMutex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PredicateResults <span class="title">readLockPredicate</span><span class="params">(List&lt;String&gt; children, String sequenceNodeName)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> ( writeMutex.isOwnedByCurrentThread() )</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *如果writeMutex被当前的线程占有的话，返回new PredicateResults(null, true)</span></span><br><span class="line"><span class="comment">          *writeMutex继承自InterProcessMutex,里面的getsTheLock中返回的即是PredicateResults，</span></span><br><span class="line"><span class="comment">          *var1 表示watchThePath为空，不对其他所节点进行监听，</span></span><br><span class="line"><span class="comment">          *var2 表示haveTheLock，表示获得读锁，这里面继续了类描述里面的锁降级</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>         firstWriteIndex = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>         ourIndex = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> ( String node : children )</span><br><span class="line">        {</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> ( node.contains(WRITE_LOCK_NAME) )</span><br><span class="line">            {</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *	如果当前线程没有被写锁占有，且node路径包含写锁标识</span></span><br><span class="line"><span class="comment">             *	计算出最小值赋值给firstWriteIndex</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                firstWriteIndex = Math.min(index, firstWriteIndex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( node.startsWith(sequenceNodeName) )</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">              *	正常情况下包含读锁，进行ourIndex的赋值</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                ourIndex = index;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ++index;</span><br><span class="line">        }</span><br><span class="line">        StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line">	</span><br><span class="line">      	<span class="comment">/**</span></span><br><span class="line"><span class="comment">      	*通过上一轮loop赋值，如果ourInde小于写锁的下表，那getsTheLock为ture,可以获得读锁，否者获取读锁</span></span><br><span class="line"><span class="comment">      	*为false，且要监听读锁的路径，这里体现了写锁的独占性。只有当写锁释放了之后，其他读锁才在此线程中进</span></span><br><span class="line"><span class="comment">      	*行竞争。    </span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">boolean</span>     getsTheLock = (ourIndex &lt; firstWriteIndex);</span><br><span class="line">        String      pathToWatch = getsTheLock ? <span class="keyword">null</span> : children.get(firstWriteIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch, getsTheLock);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试过程-v3"><a class="header-anchor" href="#测试过程-v3">¶</a>测试过程</h4>
<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       CuratorFramework curatorFramework = CuratorFrameworkFactory.builder().</span><br><span class="line">               connectString(CONNECTION_STR).sessionTimeoutMs(<span class="number">5000</span>).</span><br><span class="line">               retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).build();</span><br><span class="line">       curatorFramework.start();</span><br><span class="line">       <span class="keyword">final</span> InterProcessReadWriteLock lock = <span class="keyword">new</span> InterProcessReadWriteLock(curatorFramework, <span class="string">"/locks"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> j =i;</span><br><span class="line">           <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;尝试竞争读锁"</span>);</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   <span class="keyword">if</span>(j%<span class="number">3</span>==<span class="number">0</span>) {</span><br><span class="line">                       lock.writeLock().acquire();</span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功获得了写锁"</span>);</span><br><span class="line">                   }<span class="keyword">else</span> {</span><br><span class="line">                       lock.readLock().acquire(); <span class="comment">//阻塞竞争锁</span></span><br><span class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功获得了读锁"</span>);</span><br><span class="line">                   }</span><br><span class="line"></span><br><span class="line">               } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">               } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               } <span class="keyword">finally</span> {</span><br><span class="line">                   <span class="keyword">try</span> {</span><br><span class="line">                       <span class="comment">//释放锁</span></span><br><span class="line">                       <span class="keyword">if</span>(j%<span class="number">3</span>==<span class="number">0</span>) {</span><br><span class="line">                           lock.writeLock().release();</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功释放了写锁"</span>);</span><br><span class="line">                       }<span class="keyword">else</span> {</span><br><span class="line">                           lock.readLock().release();</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;成功释放了读锁"</span>);</span><br><span class="line">                       }</span><br><span class="line"></span><br><span class="line">                   } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }, <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p>测试结果：从下面的结果可以看出，读锁和写锁相互竞争，多个线程同时获取读锁，但是写锁是独占的，需要释放之后，该线程才被加入到竞争中。</p>
<p><img src="/images/loading.gif" data-original="threads-monitor-3.png" alt=""></p>
<h2 id="Redis分布式锁"><a class="header-anchor" href="#Redis分布式锁">¶</a>Redis分布式锁</h2>
<p>我们先来看分布式锁RedissonLock的调用方式</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Redisson redisson = Redisson.create();</span><br><span class="line"></span><br><span class="line">        RLock lock = redisson.getLock(<span class="string">"haogrgr"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"hagogrgr"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>先看看类的调用关系，Redisson实现了父类RLock的接口</p>
<p><img src="/images/loading.gif" data-original="redisson-lock-layout.png" alt=""></p>
<p>先看看常用的Lock方法的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">lockInterruptibly();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">lockInterruptibly(-<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再看lockInterruptibly方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"><span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="keyword">null</span>) { </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *	获取成功,为什么ttl == null可以判断获取为空，具体的tryAcquire再后续有讲解</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 异步订阅redis chennel</span></span><br><span class="line">RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line"><span class="comment">// 阻塞获取订阅结果</span></span><br><span class="line">commandExecutor.syncSubscription(future); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"><span class="comment">// 循环判断知道获取锁</span></span><br><span class="line">ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// waiting for message</span></span><br><span class="line"><span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) {</span><br><span class="line">getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">getEntry(threadId).getLatch().acquire();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">unsubscribe(future, threadId);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>总结<code>lockInterruptibly</code>：获取锁，不成功则订阅释放锁的消息，获得消息前阻塞。得到释放通知后再去循环获取锁。</p>
<p>下面看看如何获取锁：Long ttl = tryAcquire(leaseTime, unit, threadId)</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> get(tryLockInnerAsync(leaseTime, unit, Thread.currentThread().getId()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> get(tryLockInnerAsync(Thread.currentThread().getId()));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>如果leaseTime != -1，调用tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG)方法，需要注意的是，此处用到了Netty的Future-listen模型，这儿我不太清楚，后面我会把它挖得清清楚楚。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) { </span><br><span class="line"><span class="comment">//1 如果设置了超时时间，直接调用 tryLockInnerAsync</span></span><br><span class="line"><span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//2 如果leaseTime==-1，则默认超时时间为30s</span></span><br><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(LOCK_EXPIRATION_INTERVAL_SECONDS, TimeUnit.SECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line"><span class="comment">//3 监听Future，获取Future返回值ttlRemaining(剩余超时时间)，获取锁成功，但是ttlRemaining，则刷新过期时间</span></span><br><span class="line">ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() {</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">Long ttlRemaining = future.getNow();</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) {</span><br><span class="line">scheduleExpirationRenewal(threadId);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Future&lt;Long&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">        internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_LONG,</span><br><span class="line">                  <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                      <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                      <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                      <span class="string">"return nil; "</span> +</span><br><span class="line">                  <span class="string">"end; "</span> +</span><br><span class="line">                  <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                    Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>commandExcutor继承关系：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public interface CommandExecutor extends CommandSyncExecutor, CommandAsyncExecutor {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类的调用关系：</p>
<p><img src="/images/loading.gif" data-original="command-executor-layout.png" alt=""></p>
<p>以上evalWriteAsync方法调用redis执行EVAL 命令来执行Lua脚本，<a href="http://redisdoc.com/script/eval.html" target="_blank" rel="noopener">Lua脚本参考文档</a>，我们看一下执行获取锁的步骤：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">-- <span class="number">1</span>. 没被锁{key不存在}</span><br><span class="line">eval <span class="string">"return redis.call('exists', KEYS[1])"</span> <span class="number">1</span> myLock</span><br><span class="line">-- (<span class="number">1</span>) 设置Lock为key，uuid:threadId为filed, filed值为<span class="number">1</span></span><br><span class="line">eval <span class="string">"return redis.call('hset', KEYS[1], ARGV[2], 1)"</span> <span class="number">1</span> myLock <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- (<span class="number">2</span>) 设置key过期时间{防止获取锁后线程挂掉导致死锁}</span><br><span class="line">eval <span class="string">"return redis.call('pexpire', KEYS[1], ARGV[1])"</span> <span class="number">1</span> myLock <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">2</span>. 已经被同线程获得锁{key存在并且field存在}</span><br><span class="line">eval <span class="string">"return redis.call('hexists', KEYS[1], ARGV[2])"</span> <span class="number">1</span> myLock <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- (<span class="number">1</span>) 可重入，但filed字段+<span class="number">1</span></span><br><span class="line">eval <span class="string">"return redis.call('hincrby', KEYS[1], ARGV[2],1)"</span> <span class="number">1</span> myLock <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- (<span class="number">2</span>) 刷新过去时间</span><br><span class="line">eval <span class="string">"return redis.call('pexpire', KEYS[1], ARGV[1])"</span> <span class="number">1</span> myLock <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">3</span>. 已经被其他线程锁住{key存在，但是field不存在}：以毫秒为单位返回 key 的剩余超时时间</span><br><span class="line">eval <span class="string">"return redis.call('pttl', KEYS[1])"</span> <span class="number">1</span> myLock</span><br></pre></td></tr></tbody></table></figure>
<p>以下是释放锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">												</span><br><span class="line">-- <span class="number">1</span>. key不存在</span><br><span class="line">eval <span class="string">"return redis.call('exists', KEYS[1])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- (<span class="number">1</span>) 发送释放锁的消息，返回<span class="number">1</span>，释放成功</span><br><span class="line">eval <span class="string">"return redis.call('publish', KEYS[2], ARGV[1])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">2</span>. key存在，但field不存在，说明自己不是锁持有者，无权释放，直接<span class="keyword">return</span> nil</span><br><span class="line">eval <span class="string">"return redis.call('hexists', KEYS[1], ARGV[3])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">eval <span class="string">"return nil"</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">3</span>. filed存在，说明是本线程在锁，但有可能其他地方重入锁，不能直接释放，应该-<span class="number">1</span></span><br><span class="line">eval <span class="string">"return redis.call('hincrby', KEYS[1], ARGV[3]，-1)"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">4</span>. 如果减<span class="number">1</span>后大于<span class="number">0</span>，说明还有其他重入锁，刷新过期时间,返回<span class="number">0</span>。</span><br><span class="line">eval <span class="string">"return redis.call('pexpire', KEYS[1], ARGV[2])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line"> </span><br><span class="line">-- <span class="number">5</span>. 如果不大于<span class="number">0</span>，说明最后一把锁，需要释放</span><br><span class="line">-- 删除key</span><br><span class="line">eval <span class="string">"return redis.call('del', KEYS[1])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- 发释放消息</span><br><span class="line">eval <span class="string">"return redis.call('publish', KEYS[2], ARGV[1])"</span> <span class="number">2</span> myLock redisson_lock__channel_lock <span class="number">0</span> <span class="number">3000</span> <span class="number">3</span>d7b5418-a86d-<span class="number">48</span>c5-ae15-<span class="number">7f</span>e13ef0034c:<span class="number">110</span></span><br><span class="line">-- 返回<span class="number">1</span>，释放成功</span><br></pre></td></tr></tbody></table></figure>
<p>从释放锁代码中看到，删除key后会发送消息，所以上文提到获取锁失败后，阻塞订阅此消息。</p>
<p>另外，上文提到刷新过期时间方法<code>scheduleExpirationRenewal</code>，指线程获取锁后需要不断刷新失效时间，避免未执行完锁就失效。这个方法的实现原理也类似，只是使用了Netty的TimerTask，每到过期时间1/3就去重新刷一次，如果key不存在则停止刷新。Timer实现大概如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nettyTimer</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> expireTime = <span class="number">6</span>;</span><br><span class="line">EventExecutorGroup group = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line">timer.newTimeout(timerTask -&gt; {</span><br><span class="line">Future&lt;Boolean&gt; future = group.submit(() -&gt; {</span><br><span class="line">System.out.println(<span class="string">"刷新key的失效时间为"</span>+expireTime +<span class="string">"秒"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 但key不存在时，返回true</span></span><br><span class="line">});</span><br><span class="line">future.addListener(future1 -&gt; {</span><br><span class="line"><span class="keyword">if</span> (!future.getNow()) {</span><br><span class="line">nettyTimer();</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}, expireTime/<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试结果"><a class="header-anchor" href="#测试结果">¶</a>测试结果</h4>
<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现锁逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getRedisLock</span><span class="params">()</span>   </span>{</span><br><span class="line">        <span class="comment">//redisson配置</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        SingleServerConfig singleSerververConfig = config.useSingleServer();</span><br><span class="line">        singleSerververConfig.setAddress(<span class="string">"127.0.0.1:6379"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//redisson客户端</span></span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            lock.tryLock(<span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);<span class="comment">//第一个参数代表等待时间，第二是代表超过时间释放锁，第三个代表设置的时间制</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"执行"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<p><img src="/images/loading.gif" data-original="redis-d-lock-result.png" alt="redis-d-lock-result"></p>
<p>redis monitor ：</p>
<p><img src="/images/loading.gif" data-original="redis-monitor.png" alt="redis-monitor">我们来回过头来看evalWriteAsync的里面Lua脚本的执行过程，看看到底去哪儿执行了。<a href="https://www.jianshu.com/p/06d7eb29b35f" target="_blank" rel="noopener">以下分析来自原文</a>，通过下面的类可以知道是到了CommandAsyncService里面执行，如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandAsyncService</span> <span class="keyword">implements</span> <span class="title">CommandAsyncExecutor</span> </span>{</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">Future&lt;R&gt; <span class="title">evalWriteAsync</span><span class="params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object ... params)</span> </span>{</span><br><span class="line">        NodeSource source = getNodeSource(key);</span><br><span class="line">        <span class="keyword">return</span> evalAsync(source, <span class="keyword">false</span>, codec, evalCommandType, script, keys, params);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> &lt;T, R&gt; <span class="function">Future&lt;R&gt; <span class="title">evalAsync</span><span class="params">(NodeSource nodeSource, <span class="keyword">boolean</span> readOnlyMode, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object ... params)</span> </span>{</span><br><span class="line">        Promise&lt;R&gt; mainPromise = connectionManager.newPromise();</span><br><span class="line">        List&lt;Object&gt; args = <span class="keyword">new</span> ArrayList&lt;Object&gt;(<span class="number">2</span> + keys.size() + params.length);</span><br><span class="line">        args.add(script);</span><br><span class="line">        args.add(keys.size());</span><br><span class="line">        args.addAll(keys);</span><br><span class="line">        args.addAll(Arrays.asList(params));</span><br><span class="line">        async(readOnlyMode, nodeSource, codec, evalCommandType, args.toArray(), mainPromise, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> mainPromise;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>追本溯源，看看async实现，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V, R&gt; <span class="function"><span class="keyword">void</span> <span class="title">async</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> readOnlyMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> NodeSource source,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> Codec codec,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> RedisCommand&lt;V&gt; command,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> Object[] params,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> Promise&lt;R&gt; mainPromise,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">int</span> attempt)</span> </span>{</span><br><span class="line">    <span class="comment">// ....省略部分代码....</span></span><br><span class="line">    <span class="comment">// AsyncDetails 是一个包装对象，用来将异步调用过程中的对象引用包装起来方便使用</span></span><br><span class="line">    <span class="keyword">final</span> AsyncDetails&lt;V, R&gt; details = AsyncDetails.acquire();</span><br><span class="line">    details.init(connectionFuture, attemptPromise,</span><br><span class="line">            readOnlyMode, source, codec, command, params, mainPromise, attempt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retryTimerTask 用来实现 Redisson 提供的重试机制</span></span><br><span class="line">    <span class="keyword">final</span> TimerTask retryTimerTask = <span class="keyword">new</span> TimerTask() {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout t)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="comment">// ....省略部分代码....</span></span><br><span class="line">            <span class="keyword">int</span> count = details.getAttempt() + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ....省略部分代码....</span></span><br><span class="line">            async(details.isReadOnlyMode(), details.getSource(),</span><br><span class="line">                    details.getCodec(), details.getCommand(),</span><br><span class="line">                    details.getParams(), details.getMainPromise(), count);</span><br><span class="line">            AsyncDetails.release(details);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// 启用重试机制</span></span><br><span class="line">    Timeout timeout = connectionManager.newTimeout(retryTimerTask,</span><br><span class="line">            connectionManager.getConfig().getRetryInterval(),</span><br><span class="line">            TimeUnit.MILLISECONDS);</span><br><span class="line">    details.setTimeout(timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checkConnectionFuture 用于检查客户端是否与服务端集群建立连接，如果连接建立</span></span><br><span class="line">    <span class="comment">// 则可发送命令到服务端执行</span></span><br><span class="line">    <span class="keyword">if</span> (connectionFuture.isDone()) {</span><br><span class="line">        checkConnectionFuture(source, details);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        connectionFuture.addListener(<span class="keyword">new</span> FutureListener&lt;RedisConnection&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;RedisConnection&gt; connFuture)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                checkConnectionFuture(source, details);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....省略部分代码....</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;R, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">checkConnectionFuture</span><span class="params">(<span class="keyword">final</span> NodeSource source,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> AsyncDetails&lt;V, R&gt; details)</span> </span>{</span><br><span class="line">    <span class="comment">// ....省略部分代码....</span></span><br><span class="line">    <span class="comment">// 获取客户端与服务端集群建立的连接</span></span><br><span class="line">    <span class="keyword">final</span> RedisConnection connection = details.getConnectionFuture().getNow();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (details.getSource().getRedirect() == Redirect.ASK) {</span><br><span class="line">        <span class="comment">// 客户端接收到 ASK 转向, 先发送一个 ASKING 命令，然后再发送真正的命令请求</span></span><br><span class="line">        <span class="comment">// ....省略部分代码....</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ....省略部分代码....</span></span><br><span class="line">        <span class="comment">// 客户端发送命令到服务端</span></span><br><span class="line">        ChannelFuture future = connection.send(<span class="keyword">new</span> CommandData&lt;V, R&gt;(details.getAttemptPromise(),</span><br><span class="line">                details.getCodec(), details.getCommand(), details.getParams()));</span><br><span class="line">        details.setWriteFuture(future);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ....省略部分代码....</span></span><br><span class="line">    <span class="comment">// 释放本次连接</span></span><br><span class="line">    releaseConnection(source, details.getConnectionFuture(), details.isReadOnlyMode(),</span><br><span class="line">            details.getAttemptPromise(), details);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于代码太长，我只贴出了和执行命令有关的部分代码，我们可以从上面代码中看到</p>
<ul>
<li>Redisson 对每次操作都提供了重试机制，可配置 <code>retryAttempts</code> 来控制重试次数（缺省为3次），可配置 <code>retryInterval</code> 来控制重试间隔（缺省为 1000 ms）。Redisson 中使用了 Netty 的 <code>TimerTask</code> 和 <code>Timeout</code> 工具来实现其重试机制。</li>
<li>Redisson 中也大量使用了 Netty 实现的异步工具 <code>Future</code> 和 <code>FutureListener</code>，使得异步调用执行完成后能够立刻做出对应的操作。</li>
<li>RedissonConnection 是基于 Netty 实现的，发送命令的 <code>send</code> 方法实现是使用 Netty 的 <code>Channel.writeAndFlush</code> 方法。</li>
</ul>
<p>Redisson使用了Netty链接redis的服务，并依赖Netty异步工具来实现异步通信、重试、阻塞等特性，之后再补全Netty的知识再继续更新！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>服务端编程</tag>
      </tags>
  </entry>
  <entry>
    <title>做了个梦</title>
    <url>/2020/03/28/dreamviewer/</url>
    <content><![CDATA[<blockquote>
<p>2020-03-28 做了个梦，感觉有点意思，把它记录下来</p>
</blockquote>
<p>​       在我30多岁这一年的这一天，我一个以前的同事，把中小学课程通过盗版渠道成立了一个在线教育和直播平台，居然做成了全国的规范。中午他又和同事因为处事方式的激进和不可调和，在办公园区大打出手，脸上挂红，其实我和他已经好几年没有联系了，很大原因也是因为他的脾气确实也是烂得没话说。 <a id="more"></a>平时虽然我和他在一个城市，我都懒得和他打交道，确实人格令人讨厌，但是今天他找到了我，我还是憋着不快听了他和我抱怨他同事怎么不尊重他为他们企业的付出，作为一个新人如何对他指点江山，这让他蒙羞。因为他确实把一个烂App做成全国平台，实际意义的公司创始人。所以，虽然一大把年纪了，他也动手了！狠狠地揍了这个小屁孩。因为今天是工作日，中午看到他脸上挂红，我才勉强受邀过来听他瞎扯的。现在穿过他住的地方，他现在算存了不少钱了，但是还住在城中村，这和他守财奴的性格还真是他娘的配的一脸。我和他穿过了通勤的羊肠小道，傍边有卖油炸粑粑的，炸洋芋的，各种生意的妇人摆着小摊生意的家伙什，小矮凳，一个生火用的小炉子，上面一口装着贩卖产品的小锅，有赶集时候的烟火气。我们穿过了这些，合中午3点钟左右，分道扬镳了，他去他早上刚挂完彩的公司上班，我也开始去上班了，这么多年来在自己专业领域的辛勤专研，似乎现在晚一点上班，其实并不会让我自己在人们心里面的权威有任何影响。就在这个时候，前不搭村后不搭店的来了一个越野车，车里坐满了拿着开荒工具的各种人，充满了在历史书里看到古早时期去美洲淘金热的场景，我不自觉鬼使神差地上了那一趟车，跟着同伙都觉着，是很好的投资机会在邀请自己，傻兮兮地被介绍到一个我都并不熟悉的南美城市，危地马拉，到达地全是热带的景观和遮天蔽日的绿林，后来我是才知道被商人当做农奴贩卖到这这里，时间过去一天又一天，终于环境，我下面的描述，开启沉浸视角，你肯定能领会一二，在一片开阔地上，我正在坐着被强迫做的工作，割橡胶、除除草之类的吧，这片开阔地是热带雨林边上灌木、野草杂生的地方，我累了，两颊汗如雨注的咸汗，端视了这个我已经因为忘记了什么原因，主动投入进来的牢笼，已经十多二十年了，这逼近天际线的远方密林，对于热爱自然的我来说，居然有这不尽的压迫感，天空只露出比一线天景观多了那么一点的位置，其他的都被茂密伫立的绿油油和潮湿多蚊虫的密林直接和天际线连接，虽然我热爱植物，热爱自然，也提不起对这里爱的感受，就算我站立在很宽的灌木丛大阔地上，远方的密林仍然让我感觉到这个世界的另外一头发生了平面的卷积，正在卷向我，我就像小时候印象里被夏天凉席从一头卷向自己的感觉，但是，这次是另一边的地球地平线卷向我，我也不知道这种奴役的生活还有多久，似乎我已经习惯了我是这片土地的一员，已经被这里的草木同化，不再有浓烈的离开的愿望，完全忘记了地球的哪一头我的父亲母亲和妹妹，已经快20年过去了，我竟然这么自然地接受了偶然事故造成的我们远离！</p>
<p>​		倏尔，起火了，我看见向我卷积的热带雨林带着炙烤的温度，像太阳表面发生巨变的耀斑的火球，点缀着束缚我快20年的这片密林，真的越来热了，它真在卷向我，时不时有人从还未被，或者已经被卷进去的地平线的卷积面冲了出来，有身上已经着火的，有身上没有着火的，一阵狼嚎哭喊，全冲了出来，不仅有平时一起的劳工，还有属于这边土地，享受这人民奉养的土地拥有者，全出来了，往地球的另一端逃离。我心里也害怕极了，掉过头来，往地球的另一头跑去，这次的火感觉和平时的火灾不一样，像是要把地球当成夏天凉席裹成一卷，然后生生烧光，我没命的跑，从地球的一头跑到了一头，从南美洲穿过无尽的连绵烧起来的地貌，可能过海的时候我也是游过来的，我也不知道这一切怎么产生，一直到亚洲，到了相距一个白昼时差的家乡，但是火依然不见视觉上的小，我小时候生长的地方，也着火了，这几年可能因为环境保护的倡议，和政府的富足，整个地球的植被都火速的恢复得非常非常好，好像这种绵密是为了起火时带动火势而产生的。我这是在想啥呢，应该不会有这种奇奇怪怪的逻辑，我和本地原住居民一起灭火，我已经离开这里二十年了，我看到旁边的人，两颊斑白，实在熟悉，但是因为这火势的迅猛和脑力的退化，已经没法一下子想起来是谁了，可能故乡人自带的亲切感亦不一定，有可能是因为这么土地味的亚洲面孔。我们拿着水管朝着火源猛喷，但是一点没用啊，感觉要烧干净一切才罢休的样子，我心里一直想着父亲母亲，我往家里赶，越往里面走，感觉被密林裹住的感觉就越发强烈，时不时还有水柱从密林的缝隙冲刷出来，应该是乡亲们在外围灭火喷的，我打开了们，看到了父亲躺在椅子上，这里虽然比平时热，但是看着不时有从包围这家的密林的缝隙间冲刷出来水柱，父亲感觉一点也不慌张，也完全体会不了我跑了半个地球回到这里喊他们撤离的焦急，“快走啊，这火不是开玩笑的，从来没见过怎么大的火，妈妈，快叫上爸爸一起走”，我说道。“不要怕，这个火等一会自己就停了，都这么大的人了，做事情还怎么慌里慌张，没点长进”！父亲不耐烦地回应我，我当然觉得很惊讶，但是管不了怎么多了，我问问父亲，妹妹呢？他说在她孩子爷爷奶奶家呢，对哦，我离开很久了，妹妹自然也成家立业了，不知道是不是和以前一起谈恋爱的那个男孩，父亲说是的。我费劲了心思，把父亲母亲接到了政府安排的避难的建筑里，随着时间的推移，慢慢地火也逐渐被政府和民众控制住了，天也渐渐黑了，我站在避难所的一角，大家都杂乱地各寻空地休息，这是一片还没开始办公用的建筑用地，建筑建的差不多了，都是水泥框架，没装什么墙面玻璃。这是这几十年基建过剩留下来的，这样的建筑还有很多。多到完全超出了生产力可以覆盖的地步，只能闲置了，不想却成了这次火灾天然的避难所。接着昏暗的灯光，时不时来了过来安顿的人，还有小时候一起长大的伙伴，都布满白发和杂乱的胡须了，我实在崩不住了，眼泪在眼睛里面打转，模糊得我都看不清昏黄灯光下继续走来的人，我擦干眼眶里面的泪水，继续和前来的一起长大的小伙伴相认，“XX，好久不见了，我是xxx，这么多年你跑哪儿了，老了老了”，“这不是xx吗，我是XXX啊，居然在这遇到你，等会让我媳妇弄点花生米，我们喝两口”，“好的好的，一定一定”，我回应道。我真的很久没有见过家乡里的人了，在这次地球快被吞灭的灾难后，我们居然相遇了，心里各种情绪翻滚，都不能连续地发出声来回应在场的很面生的老朋友。“你妹妹快到了”，父亲说道。</p>
<p>​		从斑驳，布满飞尘和火烧过的灰烬的外墙边上显露出三两个人影，一个老奶奶和一个40来岁的妇女，虽然说是妇女，着装打扮很得体，小脸，优雅，很精致的妆容还没有退去，脸上很白，可能是化妆的粉，也可能是被这大火吓到发白的样子，这个人的出现，我咽喉哽咽，感觉什么东西堵住了，虽然过了很多年，但是我知道是我妹妹，接着我的眼睛里被透明的液体再次充满到模糊，我已经不知道今天我是第几次被眼泪打满了眼眶，又极力表现出不动声色的尽量得体的样子，可心里面已经数不清具体的多少种情绪在翻滚了。“你妹妹这么多年一直在幼儿园里面教书，和小朋友相处得很好，就是和婆婆家关系不太行”，慢慢又接着说，“婆婆不满意，说她居然当着她的面在家里和一起来玩的朋友喝酒划拳，不成体统”，虽然我也不赞同这种独立不管他人的做法，但是都这个时代了，虽然不同意，但是内心其实没有太多的排斥的想法了，毕竟个人价值来自独立的思考和行为方式嘛，我一直这么认为的。况且她是我妹妹，再过分一点估计我也产生不出嫌弃她来迎合别人这些行为，可能是对它的爱大于别人吧。“你妹妹在网络上还很有名，经常发表她的行业文章和分享生活点滴，就是有个很孤单的名字，地球孤星，不知道什么原因，她不太轻易表达自己的看法”，旁边的大姐接着刚才母亲的吐槽继续说道。我不知道地球孤星这个网名表现的孤独感，是不是和我这个哥哥突然失踪有关系，我想多少有点关系，因为父亲母亲老了，但是哥哥却不知道哪里去了。我感觉我的眼眶已经装不完继续冒出来的泪水了。在我克制保持体面准备闭上眼睛把眼泪包裹起来的最后一刻，我看向了她，还是很精致的妆容，但是她已经闭上了眼睛，如注的泪水挂上了她闭着的双眼，眼眶边上的些许皱纹和妆容上的白色的粉、黑色眼线的妆混在了一起，感觉像一盆水泼到了父亲用墨汁写在地上的毛笔字上，眼眶局部有着和她的精致的妆容十分不和谐的杂乱，我想我会建议可以她把地球孤星这个名字给改了。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>人文</tag>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title>《娱乐至死》读书笔记</title>
    <url>/2020/03/27/%E3%80%8A%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>灵活网关SpringCloud Gateway</title>
    <url>/2020/03/26/spring-cloud-gateway/</url>
    <content><![CDATA[<h3 id="异常处理的一头一尾"><a class="header-anchor" href="#异常处理的一头一尾">¶</a>异常处理的一头一尾</h3>
<p>​		在使用网关进行微服务管理的工程中，我们编写了包含鉴权、限流的解决方案，加在访问到业务代码API之前，下面进入流程：</p>
<p><img src="/images/loading.gif" data-original="main-frame.png" alt="项目访问控制"></p>
<center>网关控制流程图</center>
<p>​     <a id="more"></a>SpringCloud 的异常处理不同于SpringMVC或者SpringBoot下的全局异常处理,因为底层的处理器不同,具体代码层表现为继承的类不同，SpringCloud需要继承DefaultErrorWebExceptionHandler进行异常处理,，SpringMVC和SpringBoot通过@ControllerAdvice<code>和</code>@ExceptionHandler处理不同的自定义异常处理逻辑。</p>
<img src="/images/loading.gif" data-original="/2020/03/26/spring-cloud-gateway/project-layout.png" class="project-layout" width="300" height="40">
<center>项目结构图</center>
<h4 id="全局异常处理："><a class="header-anchor" href="#全局异常处理：">¶</a>全局异常处理：</h4>
<p>Order：@Order(Ordered.HIGHEST_PRECEDENCE)</p>
<p>进入全局异常处理类ErrorHandlerConfiguration</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>({ServerProperties<span class="class">.<span class="keyword">class</span>, <span class="title">ResourceProperties</span>.<span class="title">class</span>})</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ErrorHandlerConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorHandlerConfiguration</span><span class="params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ServerCodecConfigurer serverCodecConfigurer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ApplicationContext applicationContext)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.serverProperties = serverProperties;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">        <span class="keyword">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="keyword">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorWebExceptionHandler <span class="title">errorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>{</span><br><span class="line">        ExceptionHandler exceptionHandler = <span class="keyword">new</span> ExceptionHandler(</span><br><span class="line">                errorAttributes,</span><br><span class="line">                <span class="keyword">this</span>.resourceProperties,</span><br><span class="line">                <span class="keyword">this</span>.serverProperties.getError(),</span><br><span class="line">                <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        exceptionHandler.setViewResolvers(<span class="keyword">this</span>.viewResolvers);</span><br><span class="line">        exceptionHandler.setMessageWriters(<span class="keyword">this</span>.serverCodecConfigurer.getWriters());</span><br><span class="line">        exceptionHandler.setMessageReaders(<span class="keyword">this</span>.serverCodecConfigurer.getReaders());</span><br><span class="line">        <span class="keyword">return</span> exceptionHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该类在容器初始化的时候首先加载，后面的加载顺序会在Order上有体现，在errorWebExceptionHandler里面实现自定义的ExceptionHandler,在经过了所有的过滤器之后，如果不在白名单（表示此类访问直接通过，不需要进行鉴权，会在下面讲到用户鉴权），异常返回自定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">extends</span> <span class="title">DefaultErrorWebExceptionHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResultFilter resultFilter;</span><br><span class="line"></span><br><span class="line">    ExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties, ErrorProperties errorProperties, ApplicationContext applicationContext) {</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resourceProperties, errorProperties, applicationContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常请求以及属性，构造相应的返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(ServerRequest request, <span class="keyword">boolean</span> includeStackTrace)</span> </span>{</span><br><span class="line">        String notFound = <span class="string">"404 NOT_FOUND"</span>;</span><br><span class="line"></span><br><span class="line">        Result result;</span><br><span class="line">        Throwable error = <span class="keyword">super</span>.getError(request);</span><br><span class="line">        <span class="keyword">if</span> (error <span class="keyword">instanceof</span> org.springframework.cloud.gateway.support.NotFoundException) {</span><br><span class="line">            <span class="comment">//请求经过了所有filter，如果不再在白名单需要减去用户调用次数</span></span><br><span class="line">            result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"NULL_API"</span>));</span><br><span class="line">            returnCount(request);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (notFound.equals(error.getMessage())) {</span><br><span class="line">            result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"NULL_API"</span>));</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (error <span class="keyword">instanceof</span> java.net.UnknownHostException){</span><br><span class="line">            <span class="comment">//请求经过了所有filter，如果不在白名单需要减去用户调用次数</span></span><br><span class="line">            result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"UNKNOW_HOST"</span>));</span><br><span class="line">            returnCount(request);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"INTERNAL_ERROR"</span>));</span><br><span class="line">            result.setData(result.getData() + <span class="string">"："</span> + error.toString() + <span class="string">":"</span> + error.getMessage());</span><br><span class="line">            error.printStackTrace();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result.toMap();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnCount</span><span class="params">(ServerRequest request)</span></span>{</span><br><span class="line">        Boolean inWhiteList = request.exchange().getAttribute(<span class="string">"inWhiteList"</span>);</span><br><span class="line">        inWhiteList = inWhiteList == <span class="keyword">null</span> ? Boolean.FALSE : inWhiteList;</span><br><span class="line">        resultFilter.returnApiCount(request.exchange(), inWhiteList);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定响应处理方法为JSON处理的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.all(), <span class="keyword">this</span>::renderErrorResponse);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将返回的响应状态都设置为200</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpStatus <span class="title">getHttpStatus</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(HttpStatus.OK.value());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="返回值包装"><a class="header-anchor" href="#返回值包装">¶</a>返回值包装</h4>
<p>在正常返回之前结果之前，需要对用户访问总数等进行更新，调用ResultFilter对返回结果进行封装:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> ModifyResponseBodyGatewayFilterFactory modifyResponseBodyGatewayFilterFactory;</span><br><span class="line">    <span class="keyword">private</span> GatewayFilter filter;</span><br><span class="line">    <span class="keyword">private</span> SyncCountTask syncCountTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultFilter</span><span class="params">(ModifyResponseBodyGatewayFilterFactory modifyResponseBodyGatewayFilterFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RedisTemplate&lt;String, String&gt; redisTemplate,</span></span></span><br><span class="line"><span class="function"><span class="params">                        SyncCountTask syncCountTask)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.modifyResponseBodyGatewayFilterFactory = modifyResponseBodyGatewayFilterFactory;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.syncCountTask = syncCountTask;</span><br><span class="line">        filter = init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{</span><br><span class="line">        <span class="comment">//需要排除流（由于基于webFlux，modifyResponseBodyGatewayFilter结果需要阻塞流，因此需要单独处理）</span></span><br><span class="line">        String streamSign = <span class="string">"/stream/"</span>;</span><br><span class="line">        <span class="keyword">if</span> (exchange.getRequest().getPath().toString().contains(streamSign)) {</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> NettyWriteResponseFilter.WRITE_RESPONSE_FILTER_ORDER - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GatewayFilter <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> modifyResponseBodyGatewayFilterFactory.apply(c -&gt; c.setRewriteFunction(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, (<span class="title">serverWebExchange</span>, <span class="title">s</span>) -&gt; </span>{</span><br><span class="line">            serverWebExchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line"></span><br><span class="line">            Boolean inWhiteList = serverWebExchange.getAttribute(<span class="string">"inWhiteList"</span>);</span><br><span class="line">            inWhiteList = inWhiteList == <span class="keyword">null</span> ? Boolean.FALSE : inWhiteList;</span><br><span class="line"></span><br><span class="line">            HttpStatus statusCode = serverWebExchange.getResponse().getStatusCode();</span><br><span class="line">            Result result;</span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.OK) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Result serverResult = JSONObject.parseObject(s, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (serverResult.getCode() == <span class="keyword">null</span> &amp;&amp; serverResult.getMessage() == <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    }</span><br><span class="line">                    result = <span class="keyword">new</span> Result(serverResult.getData());</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    returnApiCount(serverWebExchange, inWhiteList);</span><br><span class="line">                    result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"ERROR_RESULT"</span>));</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(result.toString());</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//接口处理成功,提交后续操作</span></span><br><span class="line">                UserLimitEntity userLimitEntity = serverWebExchange.getAttribute(<span class="string">"userLimitEntity"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!inWhiteList &amp;&amp; !userLimitEntity.notCountLimit()) {</span><br><span class="line">                    syncCountTask.sync(StringUtil.toMD5(serverWebExchange.getAttribute(<span class="string">"userId"</span>),</span><br><span class="line">                            serverWebExchange.getAttribute(<span class="string">"md5Path"</span>)));</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == HttpStatus.NOT_FOUND) {</span><br><span class="line">                returnApiCount(serverWebExchange, inWhiteList);</span><br><span class="line">                changeStatusCode(serverWebExchange, HttpStatus.OK);</span><br><span class="line">                result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"UNSIGN_API"</span>));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                Boolean isServerError = statusCode == <span class="keyword">null</span> || statusCode.is5xxServerError();</span><br><span class="line">                returnApiCount(serverWebExchange, inWhiteList);</span><br><span class="line">                changeStatusCode(serverWebExchange, HttpStatus.OK);</span><br><span class="line">                <span class="keyword">if</span> (isServerError) {</span><br><span class="line">                    result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"ERROR_SERVER"</span>));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    result = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"BAD_REQUEST"</span>));</span><br><span class="line">                }</span><br><span class="line">                String message = <span class="string">"服务异常"</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    JSONObject jsonObject = JSONObject.parseObject(s);</span><br><span class="line">                    message = jsonObject.getString(<span class="string">"message"</span>);</span><br><span class="line">                    String data = jsonObject.getString(<span class="string">"data"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isEmpty(data)) {</span><br><span class="line">                        message += <span class="string">"【"</span> + data + <span class="string">"】"</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    System.err.println(<span class="string">"接口"</span> + serverWebExchange.getRequest().getPath() + <span class="string">"异常结果不统一。异常为："</span> + s);</span><br><span class="line">                }</span><br><span class="line">                result.setData(result.getData() + <span class="string">"："</span> + message);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> Mono.just(result.toString());</span><br><span class="line">        }));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Number <span class="title">str2num</span><span class="params">(String str)</span> <span class="keyword">throws</span> NumberFormatException </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(str);</span><br><span class="line">        } <span class="keyword">catch</span> (NumberFormatException e) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnApiCount</span><span class="params">(ServerWebExchange exchange, <span class="keyword">boolean</span> inWhiteList)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (inWhiteList) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        UserLimitEntity userLimitEntity = exchange.getAttribute(<span class="string">"userLimitEntity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (userLimitEntity.notCountLimit()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        returnRedisCount(exchange);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnRedisCount</span><span class="params">(ServerWebExchange exchange)</span> </span>{</span><br><span class="line">        String redisPath = RedisPath.USER_COUNT_LIMIT + exchange.getAttribute(<span class="string">"userId"</span>);</span><br><span class="line">        String md5Path = exchange.getAttribute(<span class="string">"md5Path"</span>);</span><br><span class="line">        redisTemplate.opsForZSet().incrementScore(redisPath, md5Path, -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeStatusCode</span><span class="params">(ServerWebExchange exchange, HttpStatus httpStatus)</span> </span>{</span><br><span class="line">        exchange.getResponse().setStatusCode(httpStatus);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="filter过滤请求"><a class="header-anchor" href="#filter过滤请求">¶</a>filter过滤请求</h3>
<h4 id="用户权限的过滤器"><a class="header-anchor" href="#用户权限的过滤器">¶</a>用户权限的过滤器</h4>
<p>Order：Integer.MIN_VALUE</p>
<p>一头一尾简单说完，那中间经历了哪些filter的处理过程呢，根据bean的Order加载顺序，下一个我们进行的是用户的验证AuthFilter，Order：Integer.MIN_VALUE：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">implements</span> <span class="title">MyFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthFilter</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">noPassFilter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String path = exchange.getRequest().getPath().toString();</span><br><span class="line">        String md5Path = StringUtil.toMD5(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口是否启用</span></span><br><span class="line">        Boolean exist = redisTemplate.opsForSet().isMember(RedisPath.ALL_URL, md5Path);</span><br><span class="line">        <span class="keyword">if</span> (exist == <span class="keyword">null</span> || !exist) {</span><br><span class="line">            Result nullApi = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"NULL_API"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, nullApi);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户是否有权限</span></span><br><span class="line">        List&lt;String&gt; accessTokenList = exchange.getRequest().getQueryParams().get(<span class="string">"accessToken"</span>);</span><br><span class="line">        <span class="keyword">if</span> (accessTokenList == <span class="keyword">null</span> || accessTokenList.size() &lt; <span class="number">1</span>) {</span><br><span class="line">            Result missToken = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"MISS_TOKEN"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, missToken);</span><br><span class="line">        }</span><br><span class="line">        String token = accessTokenList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        String userId = redisTemplate.opsForValue().get(RedisPath.PERMISSION + token);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(userId)) {</span><br><span class="line">            Result expiredToken = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"EXPIRED_TOKEN"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, expiredToken);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Map&lt;Object, Object&gt; permission = redisTemplate.opsForHash().entries(RedisPath.USER_INFO + userId);</span><br><span class="line">            Object obj = permission.get(md5Path);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) {</span><br><span class="line">                Result impermissibleApi = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"IMPERMISSIBLE_API"</span>));</span><br><span class="line">                <span class="keyword">return</span> ResponseUtil.newResponse(exchange, impermissibleApi);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                UserLimitEntity userLimitEntity = <span class="keyword">new</span> UserLimitEntity(obj.toString());</span><br><span class="line">                exchange.getAttributes().put(<span class="string">"userLimitEntity"</span>, userLimitEntity);</span><br><span class="line">                exchange.getAttributes().put(<span class="string">"userId"</span>, userId);</span><br><span class="line">                exchange.getAttributes().put(<span class="string">"md5Path"</span>, md5Path);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接口是否启用，通过Key值RedisPath.ALL_URL从Redis里面获取所有已经存在的API，然后对1、token是否带入参数；2、token是否为空进行判断，如果都通过，通过userId在Redis里面查找用户限制鉴权对象UserLimitEntity，UserLimitEntity和RedisPath.ALL_URL的获取都存在从MySQL缓存至Redis的过程，在下面的类InitHandler进行加载。</p>
<p>Order：1</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHandler</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(InitHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> TokenBucketClient tokenBucketClient;</span><br><span class="line">    <span class="keyword">private</span> UrlMapper urlMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitHandler</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate, TokenBucketClient tokenBucketClient, UrlMapper urlMapper)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="keyword">this</span>.tokenBucketClient = tokenBucketClient;</span><br><span class="line">        <span class="keyword">this</span>.urlMapper = urlMapper;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        initEnum();</span><br><span class="line">        List&lt;Url&gt; urls = urlMapper.getAll();</span><br><span class="line">        initUrl(urls);</span><br><span class="line">        initUrlLimit(urls);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initEnum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        LOG.info(<span class="string">"############ 枚举加载 开始 ############"</span>);</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"FailureResult.properties"</span>);</span><br><span class="line">        InputStream is = resource.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        String tmp;</span><br><span class="line">        Map&lt;String, Object[]&gt; enumValues = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">while</span> ((tmp = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(tmp) &amp;&amp; tmp.trim().indexOf(<span class="string">"#"</span>) != <span class="number">0</span>) {</span><br><span class="line">                String[] nameAndCodeMsg = tmp.split(<span class="string">"="</span>);</span><br><span class="line">                String name = nameAndCodeMsg[<span class="number">0</span>].trim();</span><br><span class="line">                String cav = nameAndCodeMsg[<span class="number">1</span>].trim();</span><br><span class="line">                String code = cav.substring(<span class="number">0</span>, cav.indexOf(<span class="string">","</span>));</span><br><span class="line">                String msg = cav.substring(cav.indexOf(<span class="string">","</span>) + <span class="number">1</span>);</span><br><span class="line">                Object[] value = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">                value[<span class="number">0</span>] = Integer.parseInt(code.trim());</span><br><span class="line">                value[<span class="number">1</span>] = msg.trim();</span><br><span class="line">                enumValues.put(name, value);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        EnumUtil.addEnum(FailureResult.class, new Class[]{int.class, String.class}, enumValues);</span><br><span class="line">        LOG.info(<span class="string">"############ 枚举加载 结束 ############"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化所有的可用url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initUrl</span><span class="params">(List&lt;Url&gt; urls)</span> </span>{</span><br><span class="line">        LOG.info(<span class="string">"############ 缓存可用的URL到redis(共计:{}) 开始 ############"</span>, urls.size());</span><br><span class="line">        String[] urlArr = <span class="keyword">new</span> String[urls.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.size(); i++) {</span><br><span class="line">            urlArr[i] = urls.get(i).getId();</span><br><span class="line">        }</span><br><span class="line">        Long result = redisTemplate.opsForSet().add(RedisPath.ALL_URL, urlArr);</span><br><span class="line">        LOG.info(<span class="string">"############ 缓存可用的URL到redis(初始化:{}) 结束 ############"</span>, result == <span class="keyword">null</span> ? <span class="number">0</span> : result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有限制接口访问频率的接口，初始化redis中对应的令牌桶信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initUrlLimit</span><span class="params">(List&lt;Url&gt; urls)</span> </span>{</span><br><span class="line">        LOG.info(<span class="string">"############ 初始化令牌桶(共计:{}) 开始 ############"</span>, urls.size());</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Url url : urls) {</span><br><span class="line">            <span class="keyword">if</span> (url.getBucketMaxSize() == <span class="number">0</span> || url.getQps() == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            tokenBucketClient.init(RedisPath.URL_LIMIT + url.getId(), url.getBucketMaxSize(), url.getQps());</span><br><span class="line">            total++;</span><br><span class="line">        }</span><br><span class="line">        LOG.info(<span class="string">"############ 初始化令牌桶(初始化:{}) 结束 ############"</span>, total);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出类InitHandler中方法initUrl()初始化了所有的存在的urls（即已经存在于数据库中的API）,缓存至Redis,我们看看Mysql视图:</p>
<p><img src="/images/loading.gif" data-original="mysql-url.png" alt=""></p>
<p>Redis视图(只缓存url的Id)：</p>
<p><img src="/images/loading.gif" data-original="redis-url.png" alt=""></p>
<p>initEnum()方法初始化返回值错误类型的枚举类加载，initUrlLimit()初始化url的令牌桶，至于令牌什么时候用，我们后面说。</p>
<h4 id="用户访问速度的过滤器"><a class="header-anchor" href="#用户访问速度的过滤器">¶</a>用户访问速度的过滤器</h4>
<p>Order：Integer.MIN_VALUE+1</p>
<p>下面进入用户访问速度的过滤器，这里用到了redis+Lua的控制逻辑，直接上代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRateFilter</span> <span class="keyword">implements</span> <span class="title">MyFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRateClient userRateClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRateFilter</span><span class="params">(UserRateClient userRateClient)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.userRateClient = userRateClient;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">noPassFilter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{</span><br><span class="line"></span><br><span class="line">        UserLimitEntity userLimitEntity = exchange.getAttribute(<span class="string">"userLimitEntity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (userLimitEntity.notRateLimit()) {</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String userId = exchange.getAttribute(<span class="string">"userId"</span>);</span><br><span class="line">        String md5Path = exchange.getAttribute(<span class="string">"md5Path"</span>);</span><br><span class="line">        String redisPath = RedisPath.USER_RATE_LIMIT + userId + <span class="string">":"</span> + md5Path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> acquire(redisPath,userLimitEntity.getRate(),exchange,chain);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title">acquire</span><span class="params">(String redisPath, Map&lt;Integer,Integer&gt; limitInfo,ServerWebExchange exchange, GatewayFilterChain chain)</span></span>{</span><br><span class="line">        LuaScriptResult acquire = userRateClient.acquire(redisPath);</span><br><span class="line">        <span class="keyword">if</span> (acquire == LuaScriptResult.NEED_INIT) {</span><br><span class="line">            userRateClient.init(redisPath, limitInfo);</span><br><span class="line">            acquire = userRateClient.acquire(redisPath);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acquire == LuaScriptResult.SUCCESS) {</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (acquire == LuaScriptResult.LIMITED) {</span><br><span class="line">            Result frequentRequest = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"FREQUENT_REQUEST"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, frequentRequest);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"user limit acquire error"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类UserRateFilte，如果不在类AuthFilter过滤器中的白名单，进入自定义的MyFilter noPassFilter()进入过滤器逻辑，其中UserLimitEntity，在上面提到的类InitHandler中，已经由用户管理系统(不用于此网关系统)Mysql缓存到Redis中，如图：</p>
<p><img src="/images/loading.gif" data-original="user-limit.png" alt=""></p>
<p>其中字段USED（已访问次数），TOTAL（总访问次数），RATE（访问速率），如：{60:10,3600:300}表示两个限制条件，此用户60秒最多可累计可访问10次，3600秒最多累计可访问300次，这个二元组个数可以根据需求随意添加。其中方法acquire()，将对用户限制的次数进行判断，并返回是否通过过滤，这里会由userRateClient加载user_rate_limit.lua对用户是否能够获取访问权限进行判断。先看看类userRateClient：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRateClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis脚本调用类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userRateLua"</span>)</span><br><span class="line">    <span class="keyword">private</span> RedisScript&lt;Long&gt; userRateScript;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRateClient</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">init</span><span class="params">(String path, Map&lt;Integer, Integer&gt; limit)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Integer max = <span class="number">0</span>;</span><br><span class="line">            StringBuilder intervalSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            intervalSb.append(<span class="string">"{"</span>);</span><br><span class="line">            StringBuilder countSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            countSb.append(<span class="string">"{"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Integer key : limit.keySet()) {</span><br><span class="line">                max = max &gt; key ? max : key;</span><br><span class="line">                intervalSb.append(key * <span class="number">1000</span>).append(<span class="string">","</span>);</span><br><span class="line">                countSb.append(limit.get(key)).append(<span class="string">","</span>);</span><br><span class="line">            }</span><br><span class="line">            intervalSb.deleteCharAt(intervalSb.length() - <span class="number">1</span>).append(<span class="string">"}"</span>);</span><br><span class="line">            countSb.deleteCharAt(countSb.length() - <span class="number">1</span>).append(<span class="string">"}"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> exec(path, UserRateLimitMethod.init, intervalSb.toString(), countSb.toString(), String.valueOf(max), String.valueOf(limit.size()));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> LuaScriptResult.ERROR;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">acquire</span><span class="params">(String path)</span> </span>{</span><br><span class="line">        LuaScriptResult exec = exec(path, UserRateLimitMethod.acquire);</span><br><span class="line">        <span class="keyword">return</span> exec;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LuaScriptResult <span class="title">exec</span><span class="params">(String path, UserRateLimitMethod method, Object... params)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;() {{</span><br><span class="line">                add(path);</span><br><span class="line">                add(method.name());</span><br><span class="line">            }};</span><br><span class="line">            Long result = redisTemplate.execute(userRateScript, keys, params);</span><br><span class="line">            <span class="keyword">return</span> LuaScriptResult.getResult(result);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> LuaScriptResult.ERROR;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>UserRateClient里面的exec(path, UserRateLimitMethod.init, intervalSb.toString(), countSb.toString(), String.valueOf(max), String.valueOf(limit.size())) 方法，intervalSb和countSb都封装成{毫秒数:可访问数}这种多个二元组的形式，@Qualifier(“userRateLua”)通过Spring Configuration加载lua脚本user_rate_limit.lua:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">redis.replicate_commands()</span><br><span class="line"></span><br><span class="line">local method = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">local curr_time_arr = redis.call(<span class="string">'TIME'</span>)</span><br><span class="line">local curr_time = curr_time_arr[<span class="number">1</span>] * <span class="number">1000</span> + math.floor(curr_time_arr[<span class="number">2</span>]/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">local Result = {SUCCESS=<span class="number">1</span>,DEFEAT=<span class="number">0</span>,LIMITED=-<span class="number">1</span>,NEEDINIT=<span class="number">99</span>}</span><br><span class="line"></span><br><span class="line">local limit_info = redis.pcall(<span class="string">'HMGET'</span>,KEYS[<span class="number">1</span>],<span class="string">'interval'</span>,<span class="string">'max_count'</span>,<span class="string">'first_time'</span>,<span class="string">'count'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">local function <span class="title">arr2str</span><span class="params">(arr)</span></span></span><br><span class="line"><span class="function">    local str </span>=  <span class="string">'{'</span></span><br><span class="line">    for i=1,#arr,1 do</span><br><span class="line">        str = str .. arr[i]</span><br><span class="line">        if i&lt;#arr then</span><br><span class="line">            str = str .. <span class="string">','</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">return</span> str .. <span class="string">'}'</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'init'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(limit_info[<span class="number">1</span>]) ~=<span class="string">'boolean'</span> and limit_info[<span class="number">1</span>] ~=nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.DEFEAT</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local curr_time_str = <span class="string">'{'</span></span><br><span class="line">    local count_str = <span class="string">'{'</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,ARGV[<span class="number">4</span>],<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        curr_time_str = curr_time_str .. curr_time</span><br><span class="line">        count_str = count_str .. <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; tonumber(ARGV[<span class="number">4</span>]) then</span><br><span class="line">            curr_time_str = curr_time_str .. <span class="string">','</span></span><br><span class="line">            count_str = count_str .. <span class="string">','</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    curr_time_str = curr_time_str .. <span class="string">'}'</span></span><br><span class="line">    count_str = count_str .. <span class="string">'}'</span></span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">'HMSET'</span>, KEYS[<span class="number">1</span>],</span><br><span class="line">        <span class="string">'interval'</span>, ARGV[<span class="number">1</span>],</span><br><span class="line">        <span class="string">'max_count'</span>, ARGV[<span class="number">2</span>],</span><br><span class="line">        <span class="string">'first_time'</span>, curr_time_str,</span><br><span class="line">        <span class="string">'count'</span>, count_str)</span><br><span class="line">    redis.pcall(<span class="string">'EXPIRE'</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'acquire'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(limit_info[<span class="number">1</span>]) ==<span class="string">'boolean'</span> or limit_info[<span class="number">1</span>] ==nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.NEEDINIT</span><br><span class="line">    end</span><br><span class="line">    local interval = loadstring(<span class="string">'return '</span> .. limit_info[<span class="number">1</span>])()</span><br><span class="line">    local max_count = loadstring(<span class="string">'return '</span> .. limit_info[<span class="number">2</span>])()</span><br><span class="line">    local first_time = loadstring(<span class="string">'return '</span> .. limit_info[<span class="number">3</span>])()</span><br><span class="line">    local count = loadstring(<span class="string">'return '</span> .. limit_info[<span class="number">4</span>])()</span><br><span class="line"></span><br><span class="line">    for i=1,#interval,1 do</span><br><span class="line">        <span class="keyword">if</span> curr_time-first_time[i] &gt; interval[i] then</span><br><span class="line">            first_time[i] = curr_time</span><br><span class="line">            count[i] = <span class="number">0</span></span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">if</span> count[i] &gt;= max_count[i] then</span><br><span class="line">            <span class="keyword">return</span> Result.LIMITED</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    for i=1,#interval,1 do</span><br><span class="line">        count[i] = count[i] + <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">'HSET'</span>, KEYS[<span class="number">1</span>], <span class="string">'first_time'</span>, arr2str(first_time),<span class="string">'count'</span>,arr2str(count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>如果不懂lua脚本语法，可以去网上先了解一下，作为redis分布式锁原子性实现的利器（redis官方推出的解决方案），在进行redis分布式锁设计的时候也可以大展拳脚，实际顺手程度非常推荐。说远了，回来到上面的lua脚本。init方法初始化用户限流的各项参数，interval-时间间隔，max_count-最大访问次数，first_time-第一次访问时间，count-置0，当然是实际是{0}样子，上面做了字符串的拼接，这是lua的数组包装形式，在acquire方法里面如果redis里面没有进行初始化的话就进行初始化，在Redis里面的视图是：</p>
<p><img src="/images/loading.gif" data-original="user-rate-limit.png" alt=""></p>
<p>acquire发现，如果当前时间减去第一次时间大于时间间隔，用户已使用次数count归0，并把curr_time（当前时间）赋值给first_time（第一次时间）,如果在这个时间间隔内，使用次数count+1，如果访问次数大于最大访问次数，返回Result.LIMITED，如果返回Result.SUCCESS，通过类UserRateFilter的过滤条件，进入下一个过滤器。</p>
<h4 id="接口访问速度的过滤器"><a class="header-anchor" href="#接口访问速度的过滤器">¶</a>接口访问速度的过滤器</h4>
<p>Order：Integer.MIN_VALUE+2</p>
<p>类UrlRateFilter是对接口访问速度的控制，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlRateFilter</span> <span class="keyword">implements</span> <span class="title">MyFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenBucketClient tokenBucketClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlRateFilter</span><span class="params">(TokenBucketClient tokenBucketClient)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.tokenBucketClient = tokenBucketClient;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">noPassFilter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String md5Path = exchange.getAttribute(<span class="string">"md5Path"</span>);</span><br><span class="line">        LuaScriptResult acquire = tokenBucketClient.acquire(RedisPath.URL_LIMIT + md5Path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acquire == LuaScriptResult.SUCCESS) {</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (acquire == LuaScriptResult.LIMITED) {</span><br><span class="line">            Result limitedApi = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"LIMITED_API"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, limitedApi);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"api limit acquire error"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE + <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用TokenBucketClient进行控制逻辑，此处的逻辑和上面的用户访问控制有点区别，这里面的初始化，即令牌的初始化在类initHandler里面的initUrlLimit()方法已经初始化了，缓存至Redis如图：</p>
<p><img src="/images/loading.gif" data-original="url-limit.png" alt=""></p>
<p>里面参数表示：bucket_max_size（令牌桶里面最大令牌数），interval（产生令牌的时间间隔），token（token数），更新时间（timestamp）。关于令牌桶的概念，不清楚的话，可先查看<a href="https://segmentfault.com/a/1190000015967922" target="_blank" rel="noopener">令牌桶概念</a>、<a href="https://www.jianshu.com/p/864ddda9288f" target="_blank" rel="noopener">实现例子</a>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis脚本调用类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"tokenBucketLua"</span>)</span><br><span class="line">    <span class="keyword">private</span> RedisScript&lt;Long&gt; rateLimitScript;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TokenBucketClient</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">init</span><span class="params">(String path, <span class="keyword">int</span> bucketMaxSize, <span class="keyword">int</span> qps)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> init(path,bucketMaxSize,getInterval(qps));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">init</span><span class="params">(String path, <span class="keyword">int</span> bucketMaxSize, <span class="keyword">float</span> interval)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> exec(path, TbRateLimitMethod.init, bucketMaxSize, interval, bucketMaxSize);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">modify</span><span class="params">(String path, <span class="keyword">int</span> bucketMaxSize, <span class="keyword">int</span> qps)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> modify(path, bucketMaxSize, getInterval(qps));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">modify</span><span class="params">(String path, <span class="keyword">int</span> bucketMaxSize, <span class="keyword">float</span> interval)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> exec(path, TbRateLimitMethod.modify, bucketMaxSize, interval);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">delete</span><span class="params">(String path)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> exec(path, TbRateLimitMethod.delete);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">acquire</span><span class="params">(String path)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> acquire(path, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LuaScriptResult <span class="title">acquire</span><span class="params">(String path, <span class="keyword">int</span> acquireToken)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> exec(path, TbRateLimitMethod.acquire, acquireToken);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LuaScriptResult <span class="title">exec</span><span class="params">(String path, TbRateLimitMethod method, Object... params)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            String[] allParams = <span class="keyword">new</span> String[params.length + <span class="number">1</span>];</span><br><span class="line">            allParams[<span class="number">0</span>] = method.name();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; params.length; index++) {</span><br><span class="line">                allParams[<span class="number">1</span> + index] = params[index].toString();</span><br><span class="line">            }</span><br><span class="line">            Long result = redisTemplate.execute(rateLimitScript,</span><br><span class="line">                    Collections.singletonList(path),</span><br><span class="line">                    allParams);</span><br><span class="line">            <span class="keyword">return</span> LuaScriptResult.getResult(result);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> LuaScriptResult.ERROR;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getInterval</span><span class="params">(<span class="keyword">int</span> qps)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000.0f</span> / qps;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>控制令牌产生的lua脚本如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">redis.replicate_commands()</span><br><span class="line"></span><br><span class="line">local Result = {SUCCESS=<span class="number">1</span>,DEFEAT=<span class="number">0</span>,LIMITED=-<span class="number">1</span>}</span><br><span class="line"></span><br><span class="line">local token_bucket_info = redis.pcall(<span class="string">'HMGET'</span>,KEYS[<span class="number">1</span>],<span class="string">'bucket_max_size'</span>,<span class="string">'interval'</span>,<span class="string">'token'</span>,<span class="string">'timestamp'</span>)</span><br><span class="line"></span><br><span class="line">local bucket_max_size = tonumber(token_bucket_info[<span class="number">1</span>])</span><br><span class="line">local interval = tonumber(token_bucket_info[<span class="number">2</span>])</span><br><span class="line">local token = tonumber(token_bucket_info[<span class="number">3</span>])</span><br><span class="line">local timestamp = token_bucket_info[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">local method = ARGV[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">local curr_time_arr = redis.call(<span class="string">'TIME'</span>)</span><br><span class="line">local curr_timestamp = curr_time_arr[<span class="number">1</span>] * <span class="number">1000</span> + math.floor(curr_time_arr[<span class="number">2</span>]/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'init'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(timestamp) ~=<span class="string">'boolean'</span> and timestamp ~=nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">'HMSET'</span>, KEYS[<span class="number">1</span>],</span><br><span class="line">        <span class="string">'bucket_max_size'</span>, ARGV[<span class="number">2</span>],</span><br><span class="line">        <span class="string">'interval'</span>, ARGV[<span class="number">3</span>],</span><br><span class="line">        <span class="string">'token'</span>, ARGV[<span class="number">4</span>],</span><br><span class="line">        <span class="string">'timestamp'</span>, curr_timestamp)</span><br><span class="line">    <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'modify'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(timestamp)==<span class="string">'boolean'</span> and timestamp==nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.DEFEAT</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">'HMSET'</span>, KEYS[<span class="number">1</span>],</span><br><span class="line">        <span class="string">'bucket_max_size'</span>, ARGV[<span class="number">2</span>],</span><br><span class="line">        <span class="string">'interval'</span>, ARGV[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'delete'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(timestamp) ==<span class="string">'boolean'</span> or timestamp ==nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">'DEL'</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> method == <span class="string">'acquire'</span> then</span><br><span class="line">    <span class="keyword">if</span>(type(timestamp) ==<span class="string">'boolean'</span> or timestamp ==nil) then</span><br><span class="line">        <span class="keyword">return</span> Result.SUCCESS</span><br><span class="line">    end</span><br><span class="line">    --获取认证消耗的令牌数</span><br><span class="line">    local acquire_token = tonumber(ARGV[<span class="number">2</span>])</span><br><span class="line">    --计算当前时间与上一次认证的时间差内改产生的令牌数</span><br><span class="line">    local reserve_token = math.max(<span class="number">0</span>, math.floor((curr_timestamp - timestamp) / interval))</span><br><span class="line">    --如果超出桶的最大令牌数，则抛弃</span><br><span class="line">    local curr_token = math.min(bucket_max_size, token + reserve_token)</span><br><span class="line">    local result = Result.LIMITED</span><br><span class="line">    --如果桶中令牌数量够则放行</span><br><span class="line">    <span class="keyword">if</span> curr_token &gt;= acquire_token then</span><br><span class="line">        result = Result.SUCCESS</span><br><span class="line">        curr_token = curr_token - acquire_token</span><br><span class="line">    end</span><br><span class="line">    --更新当前桶中的令牌数量</span><br><span class="line">    redis.pcall(<span class="string">'HSET'</span>, KEYS[<span class="number">1</span>], <span class="string">'token'</span>, curr_token)</span><br><span class="line">    --如果这次有放入令牌，则更新时间</span><br><span class="line">    <span class="keyword">if</span> reserve_token &gt; <span class="number">0</span> then</span><br><span class="line">        redis.pcall(<span class="string">'HSET'</span>, KEYS[<span class="number">1</span>], <span class="string">'timestamp'</span>, curr_timestamp)</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p>acquire方法里面 acquire_token传值是1（即每次访问消耗令牌数1），更新时间差与interval比值产生对应令牌数，如果桶里面令牌大于acquire_token，则放行，返回Result.SUCCESS，完成接口访问速率的控制。</p>
<h4 id="用户总访问次数控制过滤器"><a class="header-anchor" href="#用户总访问次数控制过滤器">¶</a>用户总访问次数控制过滤器</h4>
<p>Order：Integer.MIN_VALUE+3</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCountFilter</span> <span class="keyword">implements</span> <span class="title">MyFilter</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCountFilter</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">noPassFilter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>{</span><br><span class="line"></span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSet = redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        UserLimitEntity userLimitEntity = exchange.getAttribute(<span class="string">"userLimitEntity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userLimitEntity.notCountLimit()) {</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String redisPath = RedisPath.USER_COUNT_LIMIT + exchange.getAttribute(<span class="string">"userId"</span>);</span><br><span class="line">        String md5Path = exchange.getAttribute(<span class="string">"md5Path"</span>);</span><br><span class="line"></span><br><span class="line">        Double count = zSet.incrementScore(redisPath, md5Path, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; userLimitEntity.getUsed() != <span class="number">0</span>) {</span><br><span class="line">            zSet.incrementScore(redisPath, md5Path, userLimitEntity.getUsed());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; userLimitEntity.getTotal()) {</span><br><span class="line">            zSet.incrementScore(redisPath, md5Path, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Result limitedCount = <span class="keyword">new</span> Result(FailureResult.valueOf(<span class="string">"LIMITED_COUNT"</span>));</span><br><span class="line">            <span class="keyword">return</span> ResponseUtil.newResponse(exchange, limitedCount);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE + <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>UserLimitEntity用户控制里面有个total，表示用户可以访问最大次数，上面过滤器进行访问值的判断，如果大于，返回FailureResult.valueOf(“LIMITED_COUNT”)，错误结果通过枚举形式把配置文件的自定义的错误码（下图），在前文提到的InitHandler类中进行加载。</p>
<p>FailureResult.properties:</p>
<p><img src="/images/loading.gif" data-original="failed-result.png" alt=""></p>
<h3 id="通过网关加载访问业务层"><a class="header-anchor" href="#通过网关加载访问业务层">¶</a>通过网关加载访问业务层</h3>
<p>经过上面过滤器，我们完成了对用户的鉴权和限流的设计和控制，之后正式进行业务层逻辑访问，本文完。</p>
<p>Gitlab：<a href="http://git.octodata.com.cn/jiangyunjun/open-api-gateway" target="_blank" rel="noopener">项目地址</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud-Gateway</tag>
        <tag>服务端编程</tag>
      </tags>
  </entry>
</search>
